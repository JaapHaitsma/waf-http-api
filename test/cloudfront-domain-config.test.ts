import * as fs from "fs";
import { App, Stack } from "aws-cdk-lib";
import { Template } from "aws-cdk-lib/assertions";
import { HttpApi } from "aws-cdk-lib/aws-apigatewayv2";
import * as acm from "aws-cdk-lib/aws-certificatemanager";
import { WafHttpApi } from "../src/index";

describe("CloudFront Domain Configuration", () => {
  let app: App;
  let stack: Stack;
  let httpApi: HttpApi;
  let consoleSpy: jest.SpyInstance;

  beforeEach(() => {
    app = new App();
    stack = new Stack(app, "TestStack");
    httpApi = new HttpApi(stack, "TestApi");
    // Suppress console warnings for cleaner test output (warnings are tested separately)
    consoleSpy = jest.spyOn(console, "warn").mockImplementation();
  });

  afterEach(() => {
    consoleSpy.mockRestore();
  });

  test("CloudFront distribution without custom domain", () => {
    const wafApi = new WafHttpApi(stack, "TestWafApi", {
      httpApi,
    });

    const template = Template.fromStack(stack);

    // Verify distribution exists
    template.resourceCountIs("AWS::CloudFront::Distribution", 1);

    // Verify no Aliases property is set (undefined properties are omitted from CloudFormation)
    const distributions = template.findResources(
      "AWS::CloudFront::Distribution",
    );
    const distributionConfig =
      Object.values(distributions)[0].Properties.DistributionConfig;
    expect(distributionConfig.Aliases).toBeUndefined();
    expect(distributionConfig.ViewerCertificate).toBeUndefined();

    // Verify properties are undefined when not applicable
    expect(wafApi.customDomain).toBeUndefined();
    expect(wafApi.certificate).toBeUndefined();
  });

  test("CloudFront distribution with custom domain only (auto-certificate)", () => {
    const wafApi = new WafHttpApi(stack, "TestWafApi", {
      httpApi,
      domain: "api.example.com",
    });

    const template = Template.fromStack(stack);

    // Verify distribution has domain alias
    const distributions = template.findResources(
      "AWS::CloudFront::Distribution",
    );
    const distributionConfig =
      Object.values(distributions)[0].Properties.DistributionConfig;
    expect(distributionConfig.Aliases).toEqual(["api.example.com"]);
    expect(distributionConfig.ViewerCertificate).toBeDefined();
    expect(distributionConfig.ViewerCertificate.AcmCertificateArn.Ref).toMatch(
      /TestWafApiAutoGeneratedCert/,
    );

    // Verify ACM certificate is created
    template.resourceCountIs("AWS::CertificateManager::Certificate", 1);
    template.hasResourceProperties("AWS::CertificateManager::Certificate", {
      DomainName: "api.example.com",
      ValidationMethod: "DNS",
    });

    // Verify properties are set when domain is provided
    expect(wafApi.customDomain).toBe("api.example.com");
    expect(wafApi.certificate).toBeDefined();
  });

  test("CloudFront distribution with custom domain and provided certificate", () => {
    const certificate = acm.Certificate.fromCertificateArn(
      stack,
      "TestCert",
      "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012",
    );

    const wafApi = new WafHttpApi(stack, "TestWafApi", {
      httpApi,
      domain: "api.example.com",
      certificate,
    });

    const template = Template.fromStack(stack);

    // Verify distribution has domain alias and uses provided certificate
    const distributions = template.findResources(
      "AWS::CloudFront::Distribution",
    );
    const distributionConfig =
      Object.values(distributions)[0].Properties.DistributionConfig;
    expect(distributionConfig.Aliases).toEqual(["api.example.com"]);
    expect(distributionConfig.ViewerCertificate).toBeDefined();
    expect(distributionConfig.ViewerCertificate.AcmCertificateArn).toBe(
      "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012",
    );

    // Verify no auto-generated certificate is created
    template.resourceCountIs("AWS::CertificateManager::Certificate", 0);

    // Verify properties are set when domain and certificate are provided
    expect(wafApi.customDomain).toBe("api.example.com");
    expect(wafApi.certificate).toBe(certificate);
  });

  test("CloudFront distribution with certificate only (should ignore certificate)", () => {
    const certificate = acm.Certificate.fromCertificateArn(
      stack,
      "TestCert",
      "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012",
    );

    const wafApi = new WafHttpApi(stack, "TestWafApi", {
      httpApi,
      certificate, // Certificate provided without domain
    });

    const template = Template.fromStack(stack);

    // Verify distribution behaves like no custom domain case
    template.resourceCountIs("AWS::CloudFront::Distribution", 1);
    const distributions = template.findResources(
      "AWS::CloudFront::Distribution",
    );
    const distributionConfig =
      Object.values(distributions)[0].Properties.DistributionConfig;
    expect(distributionConfig.Aliases).toBeUndefined();
    expect(distributionConfig.ViewerCertificate).toBeUndefined();

    // Verify no certificate is created
    template.resourceCountIs("AWS::CertificateManager::Certificate", 0);

    // Verify properties are undefined when certificate is provided without domain
    expect(wafApi.customDomain).toBeUndefined();
    expect(wafApi.certificate).toBeUndefined();
  });
});

describe("Error Handling and Validation", () => {
  let app: App;
  let stack: Stack;
  let httpApi: HttpApi;

  beforeEach(() => {
    app = new App();
    stack = new Stack(app, "TestStack");
    httpApi = new HttpApi(stack, "TestApi");
  });

  describe("Domain Validation", () => {
    test("should throw descriptive error for invalid domain format", () => {
      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: "invalid..domain",
        });
      }).toThrow(/❌ Invalid domain format/);
    });

    test("should throw descriptive error for empty domain", () => {
      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: "",
        });
      }).toThrow(/❌ Invalid domain format: Domain must be a non-empty string/);
    });

    test("should throw descriptive error for domain exceeding length limit", () => {
      const longDomain = "a".repeat(250) + ".com";
      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: longDomain,
        });
      }).toThrow(
        /❌ Invalid domain format: Domain name exceeds maximum length/,
      );
    });

    test("should throw descriptive error for multiple wildcards", () => {
      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: "*.*.example.com",
        });
      }).toThrow(
        /❌ Invalid wildcard domain format.*contains multiple wildcards/,
      );
    });

    test("should throw descriptive error for non-string domain", () => {
      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: null as any,
        });
      }).toThrow(/❌ Invalid domain format: Domain must be a non-empty string/);
    });
  });

  describe("Certificate Validation", () => {
    test("should throw descriptive error for certificate in wrong region", () => {
      const certificate = acm.Certificate.fromCertificateArn(
        stack,
        "TestCert",
        "arn:aws:acm:us-west-2:123456789012:certificate/12345678-1234-1234-1234-123456789012",
      );

      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: "api.example.com",
          certificate,
        });
      }).toThrow(
        /❌ Certificate region validation failed.*must be in us-east-1 region/,
      );
    });

    test("should throw descriptive error for invalid certificate ARN format", () => {
      const certificate = acm.Certificate.fromCertificateArn(
        stack,
        "TestCert",
        "invalid-arn-format",
      );

      expect(() => {
        new WafHttpApi(stack, "TestWafApi", {
          httpApi,
          domain: "api.example.com",
          certificate,
        });
      }).toThrow(
        /❌ Certificate validation failed: Invalid certificate ARN format/,
      );
    });
  });

  describe("Certificate Generation Error Handling", () => {
    test("certificate generation error handling is implemented in constructor", () => {
      // This test verifies that the error handling logic exists in the constructor
      // The actual certificate generation error handling is tested through the try-catch
      // block in the constructor, which wraps certificate creation with descriptive errors

      // We can verify the error handling structure by reading the source code
      // and confirming that proper error handling exists for certificate generation
      const sourceCode = fs.readFileSync("src/index.ts", "utf8");

      // Verify that certificate generation is wrapped in try-catch
      expect(sourceCode).toContain("try {");
      expect(sourceCode).toContain("catch (error)");
      expect(sourceCode).toContain("Failed to create SSL certificate");
      expect(sourceCode).toContain("🔧 Troubleshooting steps:");
      expect(sourceCode).toContain(
        "💡 Alternative: Provide an existing certificate",
      );
    });
  });

  describe("Warning Messages", () => {
    test("should log enhanced warning when certificate provided without domain", () => {
      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      const certificate = acm.Certificate.fromCertificateArn(
        stack,
        "TestCert",
        "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012",
      );

      new WafHttpApi(stack, "TestWafApi", {
        httpApi,
        certificate,
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          "⚠️  WafHttpApi Warning: Certificate provided without domain",
        ),
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          "🔧 Solution: Choose one of the following options",
        ),
      );

      consoleSpy.mockRestore();
    });

    test("should log compatibility warning for certificate domain validation", () => {
      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      const certificate = acm.Certificate.fromCertificateArn(
        stack,
        "TestCert",
        "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012",
      );

      new WafHttpApi(stack, "TestWafApi", {
        httpApi,
        domain: "api.example.com",
        certificate,
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          "⚠️  Certificate domain compatibility: Full validation requires runtime AWS API access",
        ),
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining("🔧 Verification steps"),
      );

      consoleSpy.mockRestore();
    });

    test("should log wildcard domain compatibility warning", () => {
      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      const certificate = acm.Certificate.fromCertificateArn(
        stack,
        "TestCert",
        "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012",
      );

      new WafHttpApi(stack, "TestWafApi", {
        httpApi,
        domain: "*.example.com",
        certificate,
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          "⚠️  Certificate domain compatibility: Wildcard domain validation is limited at synthesis time",
        ),
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining("🔧 Manual verification"),
      );

      consoleSpy.mockRestore();
    });
  });
});
